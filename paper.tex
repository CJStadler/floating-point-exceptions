\documentclass{article}

\usepackage{listings}
\usepackage[style=numeric]{biblatex}
\addbibresource{references.bib}

\begin{document}

The Ariadne paper aimed to discover inputs that raise floating point exceptions
in a given program \cite{barr_automatic_2013}. As an extension of this work we
aim to discover inputs that lead to different exception-raising behavior between
two versions of a given program — one optimized with "fast math".

Our approach has two steps:
\begin{enumerate}
  \item Solve: find candidate inputs using an SMT solver (Z3).
  \item Search: Test inputs in the neighborhood of each candidate against P and
P' until one produces different exception traces.
\end{enumerate}

Our first step is conceptually similar to that of the Ariadne paper, differing
only in implementation choices. Our primary contribution is to test the inputs
generated by the first step on both P and P', comparing their exception-raising
behavior.

\section{Find candidate inputs}

To find an input that raises an exception at an operation in a program we should
be able to construct a formula representing the conditions under which an
exception would occur. For example, given an operation \texttt{a + b} we could
construct the formula $(a + b = \infty) \lor (a + b = -\infty)$. Solutions to
this formula would be guaranteed to raise an overflow exception if given as
inputs to the operation. And if the formula is unsatisfiable this would prove
that the operation could not raise the exception.

However, these conclusions are only sound if our formula uses a theory of
floating point numbers which corresponds to the execution environment. SMT
solvers such as Z3 do include floating point theories, but solving these
formulas is not generally practical. Adopting the approach of Ariadne we instead
construct formulae over the real numbers. To find overflow-raising inputs for
the above example we construct the formula $|a + b| > \Omega$, where $\Omega$ is
the greatest representable floating point value (e.g. \texttt{DBL\_MAX} if $a$
and $b$ are double precision values). Since floating point arithmetic is an
approximation of real arithmetic we expect that solutions to this formula are
likely to either raise an overflow or be near values which will raise an
overflow.

\begin{table}[h]
\begin{tabular}{lllll}
Expression  & Overflow             & Underflow & Invalid & Divide by Zero \\ \hline
$x \odot y$ & $|x \odot y| > \Omega$ & $0 < |x \odot y| < \omega$ & N/A & N/A \\
$x / y$     & $|x| > |y| \Omega$     & $0 < |x| < |y| \omega $ &
  $x = 0 \land y = 0$ & $x \neq 0 \land y = 0$ \\
\end{tabular}
\caption{Formulae for each exception type. Where $\odot \in \{+, -, *\}$,
  $\Omega$ is the largest representable value, and $\omega$ is the smallest
  positive "normal" value (e.g. \texttt{DBL\_MIN})}
\label{table:formulae}
\end{table}

For each instruction in the given program we construct such a formula for each
type of exception that could be raised (See \ref{table:formulae}). We do not
make formulae for inexact exceptions as these are too common to be notable.

\subsection{Implementation}

We have written a Python program which builds these formulae and solves them to
find candidate exception-raising inputs. It takes two files as inputs: LLVM IR
for $P$ and $P'$. Each of these is parsed into an AST using \textit{llvmlite},
a Python wrapper around LLVM. For each instruction in each program we build
the formulae given by \ref{table:formulae} using Z3.

When an operand of an instruction is an identifier we substitute the
corresponding expression into the formula. For example, to find an input that
causes an overflow to be raised in the second addition we would solve the
formula $|(a + b) + a| > \Omega$, since $x = a + b$.

\begin{lstlisting}
double add2(double a, double b) {
  double x = a + b;
  double y = x + a;
  return y;
}
\end{lstlisting}

This results in formulae containing only constant terms and the program
parameters, which are left free. A satisfying assignment for such a formula
therefore can be interpreted as inputs to the program.

The union of the sets of formulae from the two programs is then taken. Since $P$
and $P'$ are likely to share many instructions some of the same formulae are
generated from both programs. Finally we solve each formula (using Z3) and
return the satisfying assignments for each satisfiable formula.

\section{Search for exception raising inputs}

TODO

\section{Results}

\begin{table}[h]
\begin{tabular}{l|llll}
Program                   & Constraints (P, P') & Satisfiable & Unique inputs & Diff producing \\ \hline
turbine1                  & 48 (32, 26)         & 44          & 29            & 14             \\
turbine3                  & 48 (32, 26)         & 44          & 30            & 11             \\
jetengine                 & 106 (58, 58)        & 96          & 41            & 0              \\
carbongas                 & 26 (16, 16)         & 23          & 4             & 0              \\
odometer (fully unrolled) & 9010 (5414, 3604)   & 8108        & 3038          & 247
\end{tabular}
\end{table}

\section{Algorithm}

\begin{lstlisting}
fun main(source):
  P = compile source to LLVM without optimizations
  P' = compile source to LLVM with optimizations

  inputs = find_inputs(P, P')
  search(inputs, P, P')

fun find_inputs(P, P')
  p_formulae = make_formulae(P)
  p'_formulae = make_formulae(P')

  formulae = p_formulae ∪ p'_formulae

  inputs = collect_inputs(formulae)
  return map ()

fun collect_inputs(formulae):
  solutions = []

  for formula in formulae:
    solution = solve(formula)
    if solution is sat:
      solutions << solution.inputs

  return solutions

fun make_formulae(llvm):
  env = {} # Map of identifiers to symbolic values

  # Require that each input is in the representable range.
  inputs_constraint = True
  for f in llvm.formals:
    env[f] = f
    inputs_constraint = (inputs_constraint and (abs(f) < DBL_MAX))

  formulae = []

  for inst in llvm.instructions:
    result = symbolically_execute(inst, env)
    env[inst.destination] = result

    if inst.op == fdiv:
      # Invalid
      formulae << (inst.numerator == 0 and inst.denominator == 0)
      # DivByZero
      formulae << (inst.numerator != 0 and inst.denominator == 0)
      # Overflow
      formulae << (abs(inst.numerator) > (abs(inst.denominator * DBL_MAX)))
    else:
      # Overflow
      formulae << (abs(result) > DBL_MAX)
      # Underflow
      formulae << (abs(result) > 0 and abs(result) < DBL_MIN)

  formulae = map (f => f and inputs_constraint) formulae
  return formulae

fun search(inputs, P, P'):
  P = instrument P to check for FP exceptions
  P' = instrument P' to check for FP exceptions

  for input in inputs:
    for input in nearby_fp_numbers(input):
      p_trace = exec(P, input)
      p'_trace = exec(P', input)

      if p_trace != p'_trace:
        report_diff(input, p_trace, p'_trace)
\end{lstlisting}

\printbibheading
\printbibliography

\end{document}
