fun main(source):
  P = compile source to LLVM without optimizations
  P' = compile source to LLVM with optimizations

  inputs = find_inputs(constraints)
  search(inputs, P, P')

fun find_inputs(P, P')
  p_constraints = make_constraints(P)
  p'_constraints = make_constraints(P')

  constraints = p_constraints âˆª p'_constraints

  inputs = collect_inputs(constraints)
  return map ()

fun collect_inputs(constraints):
  solutions = []

  for constraint in constraints:
    solution = solve(constraint)
    if solution is sat:
      solutions << solution.inputs

  return solutions

fun make_constraints(llvm):
  env = {} # Map of identifiers to symbolic values

  # Require that each input is in the representable range.
  formal_constraint = True
  for f in llvm.formals:
    env[f] = f
    formal_constraint = (formal_constraint and (abs(f) < DBL_MAX))

  constraints = []

  for inst in llvm.instructions:
    result = symbolically_execute(inst, env)
    env[inst.destination] = result

    if inst.op == fdiv:
      # Invalid
      constraints << (inst.numerator == 0 and inst.denominator == 0)
      # DivByZero
      constraints << (inst.numerator != 0 and inst.denominator == 0)
      # Overflow
      constraints << (abs(inst.numerator) > (abs(inst.denominator * DBL_MAX)))
    else:
      # Overflow
      constraints << (abs(result) > DBL_MAX)
      # Underflow
      constraints << (abs(result) > 0 and abs(result) < DBL_MIN)

  constraints = Add to each constraint that 
  return constraints

fun search(inputs, P, P'):
  P = instrument P to check for FP exceptions
  P' = instrument P' to check for FP exceptions

  for input in inputs:
    for input in nearby_fp_numbers(input):
      p_trace = exec(P, input)
      p'_trace = exec(P', input)

      if p_trace != p'_trace:
        report_diff(input, p_trace, p'_trace)
